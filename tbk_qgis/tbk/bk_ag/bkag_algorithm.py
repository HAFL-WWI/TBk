# -*- coding: utf-8 -*-

"""
/***************************************************************************
 BkAG
                                 A QGIS plugin
 Generates a stand delineation based on a VHM.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-11-16
        copyright            : (C) 2022 by Raffael Bienz
        email                : raffael.bienz@ag.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Raffael Bienz'
__date__ = '2022-11-16'
__copyright__ = '(C) 2022 by Raffael Bienz'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,                       
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterString,
                       QgsVectorLayer,
                       QgsField)
from qgis.PyQt.QtCore import QVariant
from qgis.core.additions.edit import edit
import os.path
import processing
import logging, logging.handlers
import numpy as np
from datetime import datetime

from tbk.bk_ag.bk_processing import *
from tbk.bk_ag.perimeter_processing import *
from tbk.bk_ag.vhm_processing import *
from tbk.utility.tbk_utilities import *


class BkAGAlgorithm(QgsProcessingAlgorithm):
    """
    Calculates a stand delineation based on a VHM
    """

    def addAdvancedParameter(self, parameter):
        parameter.setFlags(parameter.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        return self.addParameter(parameter)

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_ROOT = 'output_root'
    VHM = 'VHM'
    ROADS = 'roads'
    PERIMETER = 'perimeter'
    FIELD_DISSOLVE = 'field_dissolve'
    WINDOW_SIZE_ALL = 'window_size_all'
    WINDOW_SIZE_SH1 = 'window_size_sh1'
    WEIGHTING_SH1 = 'weighting_sh1'
    MIN_AREA_BK = 'min_area_bk'
    MIN_AREA_PERIMETER = 'min_area_perimeter'
    SIMPLIFY_THRESHOLD = 'simplify_threshold'
    LIMIT_JU = 'limit_ju'
    LIMIT_SH1 = 'limit_sh1'
    LIMIT_SH2 = 'limit_sh2'
    LIMIT_BH1 = 'limit_bh1'
    LIMIT_BH2 = 'limit_bh2'


    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # VHM 1m as main input   
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.VHM,
                self.tr('VHM 1m (.tif)'),
                [QgsProcessing.TypeRaster]
            )
        )

        # Perimeter shapefile to clip final result      
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.PERIMETER,
                self.tr("Perimeter shapefile to clip final result (.shp)"),
                [QgsProcessing.TypeVectorPolygon]
            )
        )

        # Dissolve field 
        #ToDo: Dropdown with fields
        self.addParameter(
                QgsProcessingParameterString(
                self.FIELD_DISSOLVE,
                self.tr("Field of shapefile to dissolve"),
                defaultValue = "Eigentue_1"
            )
        )

        # Shapefile of forest roads to clip stands   
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.ROADS,
                self.tr("Forest roads shapefile (lines) to clip stands (.shp)"),
                [QgsProcessing.TypeVectorLine],
                optional=True
            )
        )

        # Output folder
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUTPUT_ROOT,
                self.tr('Output folder')
            )
        )

        # Advanced parameters
        parameter = QgsProcessingParameterNumber(
            self.WINDOW_SIZE_ALL,
            self.tr("Window size for focal statistics over all cells"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=25
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.WINDOW_SIZE_SH1,
            self.tr("Window size for focal statistics over SH1 cells"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=5
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.WEIGHTING_SH1,
            self.tr("Percentage of cells so that classification = SH1"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=40,
            minValue=0,
            maxValue=100
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.SIMPLIFY_THRESHOLD,
            self.tr("Threshold for polygon simplification"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=2,
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.MIN_AREA_BK,
            self.tr("Minimum area for a stand in m2"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=2000,
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.MIN_AREA_PERIMETER,
            self.tr("Minimum area for perimeter polygons"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=100,
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.LIMIT_JU,
            self.tr("Upper limit in m for young growth"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=7,
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.LIMIT_SH1,
            self.tr("Upper limit in m for pole wood 1"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=14,
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.LIMIT_SH2,
            self.tr("Upper limit in m for pole wood 2"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=20,
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.LIMIT_BH1,
            self.tr("Upper limit in m for timber 1"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=25,
        )
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(
            self.LIMIT_BH2,
            self.tr("Upper limit in m for timber 2"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=30,
        )
        self.addAdvancedParameter(parameter)

                
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # Load data   
        vhm = str(self.parameterAsRasterLayer(parameters, self.VHM, context).source())
        perimeter = str(self.parameterAsVectorLayer(parameters, self.PERIMETER, context).source())
        roads = self.parameterAsVectorLayer(parameters, self.ROADS, context)
        output_root = self.parameterAsString(parameters, self.OUTPUT_ROOT, context)
        field_dissolve = self.parameterAsString(parameters, self.FIELD_DISSOLVE, context)  
        window_size_all = self.parameterAsInt(parameters, self.WINDOW_SIZE_ALL, context) 
        window_size_sh1 = self.parameterAsInt(parameters, self.WINDOW_SIZE_SH1, context) 
        weighting_sh1 = self.parameterAsInt(parameters, self.WEIGHTING_SH1, context)
        min_area_bk = self.parameterAsInt(parameters, self.MIN_AREA_BK, context)  
        min_area_perimeter = self.parameterAsInt(parameters, self.MIN_AREA_PERIMETER, context)
        simplify_threshold = self.parameterAsInt(parameters, self.SIMPLIFY_THRESHOLD, context)
        limit_ju = self.parameterAsInt(parameters, self.LIMIT_JU, context)  
        limit_sh1 = self.parameterAsInt(parameters, self.LIMIT_SH1, context)
        limit_sh2 = self.parameterAsInt(parameters, self.LIMIT_SH2, context)  
        limit_bh1 = self.parameterAsInt(parameters, self.LIMIT_BH1, context)
        limit_bh2 = self.parameterAsInt(parameters, self.LIMIT_BH2, context)
        reclass_table = [-99,limit_ju,1, limit_ju,limit_sh1,2, limit_sh1,limit_sh2,3, limit_sh2,limit_bh1,4, limit_bh1,limit_bh2,5, limit_bh2,99,6]

        # Set paths
        wd_path = os.path.join(output_root,f'bk_{datetime.now().strftime("%Y%m%d-%H%M")}')
        os.makedirs(wd_path, exist_ok=True)

        perimeter_path = os.path.join(wd_path, 'perimeter')
        os.makedirs(perimeter_path, exist_ok=True)

        perimeter_dissolve_path = os.path.join(perimeter_path, 'perimeter_dissolve.shp')
        perimeter_split_path = os.path.join(perimeter_path, 'perimeter_split.shp')
        perimeter_dissolve_roads_path = os.path.join(perimeter_path, 'perimeter_dissolve_roads.shp')
        perimeter_clean_roads_path = os.path.join(perimeter_path, 'perimeter_clean_roads.shp')

        vhm_clipped_path = os.path.join(wd_path, 'vhm_tiles')
        os.makedirs(vhm_clipped_path, exist_ok=True)

        shape_path = os.path.join(wd_path, 'shapefiles')
        os.makedirs(shape_path, exist_ok=True)

        final_output_path = os.path.join(wd_path, 'bk_final.shp')

        logfile_tmp_path  = os.path.join(wd_path, 'bk_processing.log')

        # Setup logger
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s; %(processName)s; %(levelname)s; %(name)s; %(message)s",
            handlers=[
                logging.FileHandler(logfile_tmp_path, mode='w'),
                QgisHandler(feedback),
                logging.StreamHandler()
            ])

        rootLogger = logging.getLogger()
        rootLogger.info('Run BK AG')


        # Dissolve WE
        # ToDo: remove features smaller than certain threshold
        rootLogger.info('Dissolve perimeter')
        perimeter_dissolve_owner = processing.run("native:dissolve", {'INPUT':perimeter, 'FIELD':[field_dissolve], 'OUTPUT':'TEMPORARY_OUTPUT'})
        perimeter_dissolve_singlepart = processing.run('qgis:multiparttosingleparts', {'INPUT':perimeter_dissolve_owner['OUTPUT'], 'OUTPUT':perimeter_dissolve_path})
        perimeter_dissolve_singlepart = QgsVectorLayer(perimeter_dissolve_path, "Perimeter dissolved", "ogr")


        # Split perimeter with roads
        if roads is not None:
            rootLogger.info('Split perimeter with roads')
            processing.run("qgis:splitwithlines", {'INPUT':perimeter_dissolve_singlepart, 'LINES': roads, 'OUTPUT':perimeter_split_path})['OUTPUT']
            perimeter_split = QgsVectorLayer(perimeter_split_path)

            # Dissolve perimeter to remove small polygons
            dissolve_perimeter(perimeter_split, min_area_perimeter, perimeter_dissolve_roads_path)

            # Apply small buffer to remove geometry errors
            processing.run("native:buffer", {'INPUT':perimeter_dissolve_roads_path,'DISTANCE':1e-05,'SEGMENTS':5,'END_CAP_STYLE':0,
                'JOIN_STYLE':0,'MITER_LIMIT':2,'DISSOLVE':False,'OUTPUT':perimeter_clean_roads_path})

            perimeter_dissolve = QgsVectorLayer(perimeter_clean_roads_path)

        else:
            perimeter_dissolve = perimeter_dissolve_singlepart

        # Add id attribute
        rootLogger.info('Add id attribute')
        perimeter_dissolve.dataProvider().addAttributes([QgsField("id",QVariant.Int)])
        perimeter_dissolve.updateFields()
        field_idx = perimeter_dissolve.fields().indexOf('id')
        with edit(perimeter_dissolve):
            for i,feat in enumerate(perimeter_dissolve.getFeatures()):
                perimeter_dissolve.changeAttributeValue(feat.id(), field_idx, i)

        # Cut VHM to perimeter elements for separate calculation
        # ToDo: Use function provided by TBK (clip_vhm_to_perimeter)
        rootLogger.info('Cut VHM to perimeter')
        vhm_prefix = 'vhm_'
        cut_vhm_to_perimeter(perimeter_dissolve, vhm, vhm_prefix, vhm_clipped_path)

        # Reclassification  
        rootLogger.info('Reclassification of VHM')      
        vhm_recl_prefix = 'vhm_recl_'        
        reclassify_vhm(perimeter_dissolve, vhm_prefix, vhm_recl_prefix, reclass_table, vhm_clipped_path)

        # Focal statistics SH1 (only Ju+SH1, 40% majority, 5m)
        rootLogger.info('Focal statistics Ju+SH1')
        focal_folder (perimeter_dissolve, window_size_sh1, 'SH1', weighting_sh1, vhm_clipped_path, "vhm_recl_", vhm_clipped_path, "vhm_focal1_")

        # Focal statistics all (majority, 25m)
        rootLogger.info('Focal statistics all')
        focal_folder (perimeter_dissolve, window_size_all, 'majority', 0, vhm_clipped_path, "vhm_focal1_", vhm_clipped_path, "vhm_focal2_")

        # Convert VHM to Polygon
        rootLogger.info('Convert VHM to polygon')
        source_prefix = "vhm_focal2_"
        dest_prefix = "bk_raw_"

        vhm_to_polygon(perimeter_dissolve, source_prefix, dest_prefix, vhm_clipped_path, shape_path)

        # Simplify polygons
        rootLogger.info('Simplify polygon geometry')
        source_prefix = "bk_raw_"
        dest_prefix = "bk_simple_"

        simplify_polygons(perimeter_dissolve, source_prefix, dest_prefix, simplify_threshold, shape_path)

        # Combine polygons < 20a with neighbors
        rootLogger.info('Dissolve small polygons')
        source_prefix = "bk_simple_"
        dest_prefix = "bk_def_"

        merge_small_polygons(perimeter_dissolve, source_prefix, dest_prefix, min_area_bk, shape_path)

        # Combine polygons 
        rootLogger.info('Combine all polygons and create final output')
        source_prefix = "bk_def_"
        paths = []
        for feature in perimeter_dissolve.getFeatures():
            id = feature['id']
            name_shp = source_prefix + str(id) + '.shp'
            bk_path = os.path.join(shape_path, name_shp)
            paths.append(bk_path)

        bk_combine = processing.run("native:mergevectorlayers", {'LAYERS':paths,'CRS':None,'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']

        par = {'FIELD': 'ES', 'INPUT': bk_combine, 'OPERATOR': 1, 'OUTPUT': final_output_path, 'VALUE': 0}
        processing.run("qgis:extractbyattribute", par)


        logging.FileHandler(logfile_tmp_path).close()
        rootLogger=None

        return {self.OUTPUT_ROOT: output_root}






    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Generate BK AG'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return BkAGAlgorithm()
