# -*- coding: utf-8 -*-

#######################################################################
# Determine local density in TBk stands.
#
# (C) Alexandra Erbach, Christoph Schaller, HAFL
#######################################################################

"""
/***************************************************************************
 TBk
                                 A QGIS plugin
 Toolkit for thee generation of forest stand maps
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-08-03
        copyright            : (C) 2023 by Berner Fachhochschule HAFL
        email                : christian.rosset@bfh.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Berner Fachhochschule HAFL'
__date__ = '2020-08-03'
__copyright__ = '(C) 2023 by Berner Fachhochschule HAFL'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import time
from datetime import datetime, timedelta
import logging, logging.handlers
import sys
import osgeo.gdal as gdal
import osgeo.ogr as ogr
import osgeo.osr as osr

import math

import numpy as np
from scipy import ndimage

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterString,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterDefinition,
                       QgsVectorLayer,
                       QgsRasterLayer,
                       QgsCoordinateReferenceSystem,
                       QgsApplication)
import processing

from tbk.utility.tbk_utilities import *


class TBkPostprocessLocalDensity(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    def addAdvancedParameter(self, parameter):
        parameter.setFlags(parameter.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        return self.addParameter(parameter)



    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    # Directory containing the input files
    OUTPUT_ROOT = "output_root"

    OUTPUT = "OUTPUT"

    # radius of circular moving window (in m)
    MW_RAD = "mw_rad"
    # minimum size for dense/sparse "clumps" (in Aren)
    MIN_SIZE_CLUMP = "min_size_clump"
    # minimal density value for identification of "dense pixels" (moving window)
    MIN_DENS = "min_dens"
    # maximal density value for identification of "sparse pixels" (moving window)
    MAX_DENS = "max_dens"
    # name of forest
    NAME = "name"

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # Folder for algo input/output
        self.addParameter(QgsProcessingParameterFile(self.OUTPUT_ROOT,self.tr("Folder with TBk results"),behavior=QgsProcessingParameterFile.Folder, fileFilter='All Folders (*.*)',defaultValue=None))
        
        # name of forest
        parameter = QgsProcessingParameterString(self.NAME, self.tr("Name of the forest"), defaultValue = "bgb")
        self.addParameter(parameter)

        # radius of circular moving window (in m)
        parameter = QgsProcessingParameterNumber(self.MW_RAD, self.tr("Radius of circular moving window (in m)"), type=QgsProcessingParameterNumber.Double, defaultValue=7.0)
        self.addAdvancedParameter(parameter)

        # minimum size for dense/sparse "clumps" (in Aren)
        parameter = QgsProcessingParameterNumber(self.MIN_SIZE_CLUMP, self.tr("Minimum size for dense/sparse 'clumps' (Aren)"), type=QgsProcessingParameterNumber.Double, defaultValue=10.0)
        self.addAdvancedParameter(parameter)

        # minimal density value for identification of "dense pixels" (moving window)
        parameter = QgsProcessingParameterNumber(self.MIN_DENS, self.tr("Minimal density value for identification of 'dense pixels' (moving window)"), type=QgsProcessingParameterNumber.Double, defaultValue=0.8)
        self.addAdvancedParameter(parameter)

        # maximal density value for identification of "sparse pixels" (moving window)
        parameter = QgsProcessingParameterNumber(self.MAX_DENS, self.tr("Maximal density value for identification of 'sparse pixels' (moving window)"), type=QgsProcessingParameterNumber.Double, defaultValue=0.25)
        self.addAdvancedParameter(parameter)

    def simple_circular_weight (self, d):
        """
        d: Diameter or the circle as number of cells cells
        """
        x = [i for i in range(-math.floor(d/2),math.floor(d/2)+1,1)]
        n = len(x)
        m = np.sqrt(np.tile(x,(n,1))**2+np.repeat([[i] for i in x],n,axis=1)**2)<=d/2

        return m/m.sum()


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        output_root = self.parameterAsString(parameters, self.OUTPUT_ROOT, context)
        output_folder = os.path.join(output_root,"clumpy_results")
        ensure_dir(output_folder)

        settings_path = QgsApplication.qgisSettingsDirPath()
        feedback.pushInfo(settings_path)

        tbk_tool_path = os.path.join(settings_path,"python/plugins/tbk_qgis")


        # input
        name = self.parameterAsString(parameters, self.NAME, context)
        if (not name) or name == "":
            raise QgsProcessingException("no forest name specified")



        # radius of circular moving window (in m)
        mw_rad = self.parameterAsDouble(parameters, self.MW_RAD, context)

        # minimum size for dense/sparse "clumps" (in Aren)
        min_size_clump = self.parameterAsDouble(parameters, self.MIN_SIZE_CLUMP, context)

        # minimal density value for identification of "dense pixels" (moving window)
        min_dens = self.parameterAsDouble(parameters, self.MIN_DENS, context)

        # maximal density value for identification of "sparse pixels" (moving window)
        max_dens = self.parameterAsDouble(parameters, self.MAX_DENS, context)

        start_time = time.time()

        os_path = os.path.join(output_root,"dg_layers/dg_layer_os.tif")
        ueb_path = os.path.join(output_root,"dg_layers/dg_layer_ueb.tif")
        stands_path = os.path.join(output_root,"TBk_Bestandeskarte.shp")

        osr = QgsRasterLayer(os_path)
        uebr = QgsRasterLayer(ueb_path)
        stands = QgsVectorLayer(stands_path, 'Stands', 'ogr')

        param = {'INPUT_A':osr,'BAND_A':1,'INPUT_B':uebr,'BAND_B':1,'INPUT_C':None,'BAND_C':-1,'INPUT_D':None,'BAND_D':-1,'INPUT_E':None,'BAND_E':-1,'INPUT_F':None,'BAND_F':-1,
                 'FORMULA':'A+B','NO_DATA':None,'RTYPE':5,'OPTIONS':'','EXTRA':'','OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("gdal:rastercalculator", param)

        hs_path = algoOutput["OUTPUT"]
        hs = QgsRasterLayer(hs_path)

        
        res_hs = hs.rasterUnitsPerPixelY()

        # function which eliminates all "clumps" smaller than min. size
        def min_size_function(rast, minsize):
            sieve_result = gdal.GetDriverByName('MEM').CreateCopy('', rast)
            result = gdal.SieveFilter(rast.GetRasterBand(1), None, sieve_result.GetRasterBand(1),
                                    minsize, 8, callback = None )
            
            rast_arr = rast.ReadAsArray()
            sieve_arr = sieve_result.ReadAsArray()
            
            res_arr = (rast_arr==sieve_arr)*rast_arr+(rast_arr!=sieve_arr)*255
            
            rast.GetRasterBand(1).WriteArray(res_arr)
            return rast

        def print_vals(label, arr):
            print(label)
            print(np.unique(arr))
            print("0",len(arr[arr==0]))
            print("1",len(arr[arr==1]))
            print("255",len(arr[arr==255]))

        def print_freq(arr, label = ""):
            print(label)
            freq = np.unique(arr, return_counts=True)
            for i in range(len(freq[0])):
                print(freq[0][i],freq[1][i])    
        
        def save_array_copy(arr, template, path):
            driver = gdal.GetDriverByName('GTiff')
            dst_ds = driver.CreateCopy(path, template)
            dst_ds.GetRasterBand(1).WriteArray(arr)
            dst_ds = None

        #Main script: create attributes
        statstable = []
        poly_dense = []
        poly_sparse = []
        i = 0

        for f in stands.getFeatures():
            i+=1

            fid = f["ID"] 
            #print("FID", fid,i)

            select_expression = "\"ID\" = {0}".format(fid)
            #param = {'INPUT':stands,'EXPRESSION':select_expression,'OUTPUT':'TEMPORARY_OUTPUT'}
            #algoOutput = processing.run("native:extractbyexpression", param)
           
            QgsProject.instance().addMapLayer(stands, False)
            stands.selectByExpression(select_expression)
            param = {'INPUT':hs,'MASK':QgsProcessingFeatureSourceDefinition(stands.id(), True),'SOURCE_CRS':None,'TARGET_CRS':None,'NODATA':None,'ALPHA_BAND':False,'CROP_TO_CUTLINE':True,'KEEP_RESOLUTION':True,'SET_RESOLUTION':False,'X_RESOLUTION':None,'Y_RESOLUTION':None,'MULTITHREADING':False,'OPTIONS':'','DATA_TYPE':1,'EXTRA':'-wo CUTLINE_ALL_TOUCHED=TRUE','OUTPUT':'TEMPORARY_OUTPUT'}
            algoOutput = processing.run("gdal:cliprasterbymasklayer", param)

            #hs_crop = iface.getObject(algoOutput["OUTPUT"])
            
            gd = gdal.Open(algoOutput["OUTPUT"])
            if gd==None:
                stats = [fid,0, 0, 0, 0, 0] 
                statstable.append(stats)
                continue
            hs_crop = gd.ReadAsArray()
    

            # 1) area and dg of very dense / sparse areas per stock
            r_pix = mw_rad/res_hs
            d_pix = math.floor(2*r_pix)
            d_pix = d_pix if (d_pix%2)!=0 else d_pix+1

            fw = self.simple_circular_weight(d_pix)
            fw[fw>0]=1

            check = None

            area_sparse = None

            if (hs_crop.shape[0]>=fw.shape[0] and hs_crop.shape[1]>=fw.shape[1] ):                
                check = True
                min_sum = (len(fw[fw==1])-1)*min_dens
                max_sum = (len(fw[fw==1])-1)*max_dens

                hs_focal = hs_crop*1.0
                #print_freq(hs_focal, label="hs_focal 1")
                #save_array_copy(hs_focal,gd,os.path.join(output_folder,"tmp_hs_focal_{0}_a.tif".format(fid)))
                hs_focal[hs_focal==255] = np.inf
                #print_freq(hs_focal, label="hs_focal 2")
                #save_array_copy(hs_focal,gd,os.path.join(output_folder,"tmp_hs_focal_{0}_b.tif".format(fid)))

                hs_focal = ndimage.convolve(hs_focal, fw, mode='constant', cval=np.inf)
                #print_freq(hs_focal, label="hs_focal 3")
                #save_array_copy(hs_focal,gd,os.path.join(output_folder,"tmp_hs_focal_{0}_c.tif".format(fid)))

                hs_focal[hs_focal==np.inf] = 255
                #print_freq(hs_focal, label="hs_focal 4")
                #save_array_copy(hs_focal,gd,os.path.join(output_folder,"tmp_hs_focal_{0}.tif".format(fid)))



                arr_foc_1 = ((hs_focal >= min_sum) & (hs_focal < 255))+0
                arr_foc_2 = (hs_focal <= max_sum)+0
                #print_freq(arr_foc_2, label="arr_foc_2")
                #save_array_copy(hs_focal,gd,os.path.join(output_folder,"tmp_hs_arr_foc_2_{0}_a.tif".format(fid)))


                arr_foc_1[arr_foc_1 == 0] = 255
                arr_foc_2[arr_foc_2 == 0] = 255

                #print_freq(arr_foc_2, label="arr_foc_2 b")


                ras_foc_1 = gdal.GetDriverByName('MEM').CreateCopy('', gd)
                ras_foc_1.GetRasterBand(1).WriteArray(arr_foc_1)
                ras_foc_2 = gdal.GetDriverByName('MEM').CreateCopy('', gd)
                ras_foc_2.GetRasterBand(1).WriteArray(arr_foc_2)

                # elimination of areas smaller than min. size
                minsize = math.ceil(min_size_clump*100/res_hs**2)
                ras_foc_1 = min_size_function(ras_foc_1, minsize)
                ras_foc_2 = min_size_function(ras_foc_2, minsize)

                # calculation of dg's
                arr_foc_1 = ras_foc_1.ReadAsArray()
                arr_foc_2 = ras_foc_2.ReadAsArray()
                #print_freq(arr_foc_2, label="arr_foc_2 min")

                if len(arr_foc_1[arr_foc_1==1])>0:
                    dg_dense = round(len(arr_foc_1[(arr_foc_1==1) & (hs_crop==1)])/len(arr_foc_1[arr_foc_1==1]),2)
                else:
                    dg_dense = 0
                if len(arr_foc_2[arr_foc_2==1])>0:
                    dg_sparse = round(len(arr_foc_2[(arr_foc_2==1) & (hs_crop==1)])/len(arr_foc_2[arr_foc_2==1]),2)
                else:
                    dg_sparse = 0
                if len(hs_crop[(arr_foc_1==255) & (arr_foc_2==255) & (hs_crop<255)])>0:
                    dg_other = round(len(hs_crop[(arr_foc_1==255) & (arr_foc_2==255) & (hs_crop==1)])/len(hs_crop[(arr_foc_1==255) & (arr_foc_2==255) & (hs_crop<255)]),2)
                else:
                    dg_other = 0
                # dense / sparse total area (in Aren) 
                area_dense = round(len(arr_foc_1[arr_foc_1==1])*res_hs**2/100,2)
                area_sparse = round(len(arr_foc_2[arr_foc_2==1])*res_hs**2/100,2)
            else:
                check = False
                dg_dense = area_dense = dg_sparse = area_sparse = dg_other = clumpy = None


            ## 2) clumpiness index
            #if (leng(hs_crop[(hs_crop<255)])>0):
            #    clumpy <- lsm_c_clumpy(hs_crop)$value[2]
            stats = [fid,area_dense, dg_dense, area_sparse, dg_sparse, dg_other]
            statstable.append(stats)

            # raster to polygon
            area_thresh = 100
            tmp_shape = os.path.join(output_folder,"tmp_shp.shp")
            driver = gdal.GetDriverByName('GTiff')
            
            #tmp_rast_dense = os.path.join(output_folder,"tmp_rast_dense_{0}.tif".format(fid))
            #tmp_rast_sparse = os.path.join(output_folder,"tmp_rast_sparse_{0}.tif".format(fid))
            #dst_ds = driver.CreateCopy(tmp_rast_dense, ras_foc_1)
            #dst_ds = driver.CreateCopy(tmp_rast_sparse, ras_foc_2)

            if(len(arr_foc_1[arr_foc_1==1])>0 and check==True):
                rec = self.raster_to_smooth_vector_gdal(ras_foc_1,tmp_shape,area_thresh,i,dg_dense)
                if rec:
                    poly_dense.append(rec)

            if(len(arr_foc_2[arr_foc_2==1])>0 and check==True):
                rec = self.raster_to_smooth_vector_gdal(ras_foc_2,tmp_shape,area_thresh,i,dg_sparse)
                if rec:
                    poly_sparse.append(rec)


        #output results
        shape_out = os.path.join(output_folder,"stands_{0}_new.shp".format(name))
        ctc = QgsProject.instance().transformContext()
        QgsVectorFileWriter.writeAsVectorFormatV2(stands,shape_out,ctc,getVectorSaveOptions('ESRI Shapefile','utf-8'))
        out_layer = QgsVectorLayer(shape_out, "stands in", "ogr")

        with edit(out_layer):
            print("add fields...")        
            provider = out_layer.dataProvider()
            provider.addAttributes([QgsField("area.d", QVariant.Double),
                                    QgsField("dg.dense", QVariant.Double),
                                    QgsField("area.sp", QVariant.Double),
                                    QgsField("dg.sparse", QVariant.Double),
                                    QgsField("dg.other", QVariant.Double),
                                    QgsField("clumpy", QVariant.Double)])
            out_layer.updateFields()
            
            i = 0
            for f in out_layer.getFeatures():
                [fid,area_dense, dg_dense, area_sparse, dg_sparse, dg_other] = statstable[i]
                i+=1

                f["area.d"] = area_dense
                f["dg.dense"] = dg_dense
                f["area.sp"] = area_sparse
                f["dg.sparse"] = dg_sparse
                f["dg.other"] = dg_other

                out_layer.updateFeature(f)  
        
        dense_out = os.path.join(output_folder,"dense_{0}.shp".format(name))
        self.save_smoothed_vector(poly_dense,dense_out,stands.crs())

        sparse_out = os.path.join(output_folder,"sparse_{0}.shp".format(name))
        self.save_smoothed_vector(poly_sparse,sparse_out,stands.crs())

        delete_shapefile(tmp_shape)

        feedback.pushInfo("====================================================================")
        feedback.pushInfo("FINISHED")
        feedback.pushInfo("TOTAL PROCESSING TIME: %s (h:min:sec)" % str(timedelta(seconds=(time.time() - start_time))))
        feedback.pushInfo("====================================================================")

        return {self.OUTPUT: output_folder}

    def save_smoothed_vector(self, records, out_path, crs):
        # Create memory layer
        mem_layer = QgsVectorLayer('Multipolygon', 'mem', 'memory')
        mem_layer.startEditing()
        provider = mem_layer.dataProvider()
        provider.addAttributes([QgsField("layer", QVariant.Double),
                                QgsField("nr", QVariant.Int),
                                QgsField("dg", QVariant.Double),
                                QgsField("area", QVariant.Double)])
        mem_layer.updateFields()
        mem_layer.setCrs(crs)

        for i in range(len(records)):
            [layer,nr,dg,area,geom] = records[i]
            attr = mem_layer.dataProvider()
            feat = QgsFeature()
            feat.setAttributes([layer,nr,dg,area])
            feat.setGeometry(geom)
            attr.addFeatures([feat])

            mem_layer.commitChanges()
    
        ctc = QgsProject.instance().transformContext()
        QgsVectorFileWriter.writeAsVectorFormatV2(mem_layer,out_path,ctc,getVectorSaveOptions('ESRI Shapefile','utf-8'))
        del mem_layer
        
    #Works, provided that the raster uner the specified path is already properly written to disk -> gdal gotcha! 
    def raster_to_smooth_vector(self, raster_path, area_thresh, i, dg, layer=1.0):
        #rasterize assuming only 1 and NoData values are present
        param = {'INPUT_RASTER':raster_path,'RASTER_BAND':1,'FIELD_NAME':'VALUE','OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:pixelstopolygons", param)

        #buffer to dissolve pixel polygons and bridge diagonal joins
        param = {'INPUT':algoOutput["OUTPUT"],'DISTANCE':0.01,'SEGMENTS':5,'END_CAP_STYLE':1,'JOIN_STYLE':1,
                'MITER_LIMIT':2,'DISSOLVE':True,'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:buffer", param)

        #remove holes smaller than diameter
        param = {'INPUT':algoOutput["OUTPUT"],'MIN_AREA':area_thresh,'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:deleteholes", param)

        #dump geometry parts
        param = {'INPUT':algoOutput["OUTPUT"],'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:multiparttosingleparts", param)
        
        #eliminate all geometry parts smaller than threshold by extracting the large ones
        param = {'INPUT':algoOutput["OUTPUT"],'EXPRESSION':' to_int(area($geometry)) > {0}'.format(area_thresh),'OUTPUT':'TEMPORARY_OUTPUT'}
        processing.run("native:extractbyexpression", param)

        #dissolve geometries into one
        param = {'INPUT':algoOutput["OUTPUT"],'FIELD':[],'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:dissolve", param)
        
        ##smooth with grass v.generalize chaiken and tolerance = 0.5 
        #param = {'input':algoOutput["OUTPUT"],'type':[0,1,2],'cats':'','where':'','method':8,
        #        'threshold':0.5,'look_ahead':7,'reduction':50,'slide':0.5,'angle_thresh':3,'degree_thresh':0,'closeness_thresh':0,'betweeness_thresh':0,'alpha':1,'beta':1,'iterations':1,'-t':False,'-l':True,'output':'TEMPORARY_OUTPUT','error':'TEMPORARY_OUTPUT','GRASS_REGION_PARAMETER':None,'GRASS_SNAP_TOLERANCE_PARAMETER':-1,'GRASS_MIN_AREA_PARAMETER':0.0001,'GRASS_OUTPUT_TYPE_PARAMETER':0,'GRASS_VECTOR_DSCO':'','GRASS_VECTOR_LCO':'','GRASS_VECTOR_EXPORT_NOCAT':False}
        #algoOutput = processing.run("grass7:v.generalize", param)
        #smooth_layer = QgsVectorLayer(algoOutput["output"], "dissolve", "ogr")

        #smooth with native algorithm with 2 passes
        param = {'INPUT':algoOutput["OUTPUT"],'ITERATIONS':2,'OFFSET':0.25,'MAX_ANGLE':180,'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:smoothgeometry",param)
        smooth_layer = algoOutput["OUTPUT"]
        
        try:
            for f in smooth_layer.getFeatures():
                geom = f.geometry()
                area = geom.area()
                nr = i
                
                return [layer, nr, dg, area, geom]

            return None
        finally:
            del smooth_layer

    def raster_to_smooth_vector_gdal(self, raster, tmp_shape, area_thresh, i, dg, layer=1.0):

        srs = osr.SpatialReference()
        srs.ImportFromWkt(raster.GetProjection())
        srcband = raster.GetRasterBand(1)

        drv = ogr.GetDriverByName("ESRI Shapefile")
        dst_ds = drv.CreateDataSource(tmp_shape)
        dst_layer = dst_ds.CreateLayer("poly" , srs = srs, geom_type=ogr.wkbMultiPolygon)
        newField = ogr.FieldDefn('DN', ogr.OFTReal)
        dst_layer.CreateField(newField)

        gdal.Polygonize(srcband, None, dst_layer, 0, [], callback=None)
        dst_ds.SyncToDisk()
        dst_ds=None

        #eliminate all geometry parts with value!=1
        param = {'INPUT':tmp_shape,'EXPRESSION':'"DN" = 1'.format(area_thresh),'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:extractbyexpression", param)

        #Correctinng geometries
        param = {'INPUT':algoOutput["OUTPUT"],'DISTANCE':0.001,'SEGMENTS':5,'END_CAP_STYLE':1,'JOIN_STYLE':1,
               'MITER_LIMIT':2,'DISSOLVE':True,'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:buffer", param)

        #param = {'INPUT':algoOutput["OUTPUT"],'OUTPUT':'TEMPORARY_OUTPUT'}
        #algoOutput = processing.run("native:fixgeometries", param)

        #remove holes smaller than diameter
        param = {'INPUT':algoOutput["OUTPUT"],'MIN_AREA':area_thresh,'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:deleteholes", param)

        #dump geometry parts
        param = {'INPUT':algoOutput["OUTPUT"],'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:multiparttosingleparts", param)
        
        #eliminate all geometry parts smaller than threshold by extracting the large ones
        param = {'INPUT':algoOutput["OUTPUT"],'EXPRESSION':' to_int(area($geometry)) > {0}'.format(area_thresh),'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:extractbyexpression", param)

        #dissolve geometries into one
        param = {'INPUT':algoOutput["OUTPUT"],'FIELD':[],'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:dissolve", param)
        
        ##smooth with grass v.generalize chaiken and tolerance = 0.5 
        #param = {'input':algoOutput["OUTPUT"],'type':[0,1,2],'cats':'','where':'','method':8,
        #        'threshold':0.5,'look_ahead':7,'reduction':50,'slide':0.5,'angle_thresh':3,'degree_thresh':0,'closeness_thresh':0,'betweeness_thresh':0,'alpha':1,'beta':1,'iterations':1,'-t':False,'-l':True,'output':'TEMPORARY_OUTPUT','error':'TEMPORARY_OUTPUT','GRASS_REGION_PARAMETER':None,'GRASS_SNAP_TOLERANCE_PARAMETER':-1,'GRASS_MIN_AREA_PARAMETER':0.0001,'GRASS_OUTPUT_TYPE_PARAMETER':0,'GRASS_VECTOR_DSCO':'','GRASS_VECTOR_LCO':'','GRASS_VECTOR_EXPORT_NOCAT':False}
        #algoOutput = processing.run("grass7:v.generalize", param)
        #smooth_layer = QgsVectorLayer(algoOutput["output"], "dissolve", "ogr")

        #smooth with native algorithm with 2 passes
        param = {'INPUT':algoOutput["OUTPUT"],'ITERATIONS':2,'OFFSET':0.25,'MAX_ANGLE':180,'OUTPUT':'TEMPORARY_OUTPUT'}
        algoOutput = processing.run("native:smoothgeometry",param)
        smooth_layer = algoOutput["OUTPUT"]
        
        try:
            for f in smooth_layer.getFeatures():
                geom = f.geometry()
                area = geom.area()
                nr = i
                
                return [layer, nr, dg, area, geom]

            return None
        finally:
            del smooth_layer

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'TBk postprocess local density'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        # return self.tr(self.groupId())
        return '2 TBk Postprocessing'

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'postproc'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return TBkPostprocessLocalDensity()
