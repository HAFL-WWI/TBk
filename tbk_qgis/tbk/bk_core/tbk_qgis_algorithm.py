# -*- coding: utf-8 -*-

#######################################################################
# Generate TBk.
#
# (C) Dominique Weber, Christoph Schaller, HAFL
#######################################################################

"""
/***************************************************************************
 TBk
                                 A QGIS plugin
 Toolkit for the generation of forest stand maps
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-08-03
        copyright            : (C) 2023 by Berner Fachhochschule HAFL
        email                : christian.rosset@bfh.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Berner Fachhochschule HAFL'
__date__ = '2020-08-03'
__copyright__ = '(C) 2023 by Berner Fachhochschule HAFL'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import shutil

if __name__ == "__main__":  # this will be invoked if this module is being run directly, but not via import!
    __package__ = 'bk_core'  # make sure relative imports work when testing

# --- Imports
import os
from shutil import copyfile
from datetime import timedelta
import time
import logging, logging.handlers
import sys

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterString,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterDefinition,

                       QgsApplication)

from .tbk_create_stands import *
from .post_process import *
from .merge_similar_neighbours import *
from .clip_to_perimeter import *
from .calculate_dg import *
from .add_coniferous_proportion import *
from .attributes_default import *
from tbk_qgis.tbk.utility.qgis_processing_utility import QgisHandler
from tbk_qgis.tbk.utility.persistence_utility import write_dict_to_json_file, read_dict_from_json_file


class TBkAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    def addAdvancedParameter(self, parameter):
        parameter.setFlags(parameter.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        return self.addParameter(parameter)

    def addHiddenParameter(self, parameter):
        parameter.setFlags(parameter.flags() | QgsProcessingParameterDefinition.FlagHidden)
        return self.addParameter(parameter)

    # ------- Define Constants -------#
    # Constants used to refer to parameters and outputs.

    # These constants will be used when calling the algorithm from another algorithm,
    # or when calling from the QGIS console.

    OUTPUT = "OUTPUT"

    # Directory containing the output folder
    OUTPUT_ROOT = "output_root"
    # Directory containing the output files and subfolders with tmp and processing files
    WORKING_ROOT = "working_root"
    # File storing the parameters
    CONFIG_FILE = "config_file"
    # VHM 10m as main TBk input       
    VHM_10M = "vhm_10m"
    # VHM 150cm to calculate DG                                  
    VHM_150CM = "vhm_150cm"
    # Coniferous raster to calculate stand mean                                  
    CONIFEROUS_RASTER = "coniferous_raster"
    # Coniferous raster to be used during stand delineation
    CONIFEROUS_RASTER_FOR_CLASSIFICATION = "coniferous_raster_for_classification"
    # Perimeter shapefile to clip final result                                 
    PERIMETER = "perimeter"

    # Whether to clip the VHM prior to classification
    CLIP_VHM_BEFORE = "clip_vhm_before"

    # Default log file name
    # Will be stored in the result directory
    LOGFILE_NAME = "logfile_name"

    # --- Advanced Parameters

    # Main TBk parameters (for details see run_stand_classification function)
    # If to consider it for classification
    USE_CONFEROUS_FOR_CLASSIFICATION = "useConiferousRasterForClassification"
    # Zone raster
    ZONE_RASTER_FILE = "zoneRasterFile"
    # Short description
    DESCRIPTION = "description"
    # Relative min tolerance                                              
    MIN_TOL = "min_tol"
    # Relative max tolerance                                                      
    MAX_TOL = "max_tol"
    # Extension of the range down [m]                                                        
    MIN_CORR = "min_corr"
    # Extension of the range up [m]                                                         
    MAX_CORR = "max_corr"
    # Minimum relative amount of valid cells
    MIN_VALID_CELLS = "min_valid_cells"
    # Minimum cells per stand                                                 
    MIN_CELLS_PER_STAND = "min_cells_per_stand"
    # Minimum cells for pure mixture stands                                           
    MIN_CELLS_PER_PURE_STAND = "min_cells_per_pure_stand"
    # VHM minimum height                                       
    VHM_MIN_HEIGHT = "vhm_min_height"
    # VHM maximum height                                                   
    VHM_MAX_HEIGHT = "vhm_max_height"
    # Simplification tolerance                                                   
    SIMPLIFICATION_TOLERANCE = "simplification_tolerance"

    # Additional parameters
    # Min. area to eliminate small stands
    MIN_AREA_M2 = "min_area_m2"
    # Min. area to merge similar stands                                              
    SIMILAR_NEIGHBOURS_MIN_AREA_M2 = "similar_neighbours_min_area"
    # hdom relative diff to merge similar stands                                  
    SIMILAR_NEIGHBOURS_HDOM_DIFF_REL = "similar_neighbours_hdom_diff_rel"
    # Also calc coniferous prop. for main layer                          
    CALC_MIXTURE_FOR_MAIN_LAYER = "calc_mixture_for_main_layer"
    # Delete temporary files and fields
    DEL_TMP = "del_tmp"

    # ------- List of Algorithm Parameters -------#
    # Parameters with default values
    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along with some other properties.
        """
        # Config file
        self.addParameter(QgsProcessingParameterFile(self.CONFIG_FILE,
                                                     self.tr(
                                                         'Configuration file to set the parameters of the algorithm. '
                                                         'The parameters set in the file does not need to be set here '
                                                         'bellow'),
                                                     extension='json',
                                                     optional=True))

        # VHM 10m as main TBk input
        self.addParameter(QgsProcessingParameterRasterLayer(self.VHM_10M,
                                                            self.tr("VHM 10m as main TBk input  (.tif)")))
        # VHM 150cm to calculate DG                                  
        self.addParameter(QgsProcessingParameterRasterLayer(self.VHM_150CM,
                                                            self.tr("VHM 150cm to calculate DG (.tif)")))
        # Coniferous raster to calculate stand mean                                  
        self.addParameter(QgsProcessingParameterRasterLayer(self.CONIFEROUS_RASTER,
                                                            self.tr("Coniferous raster to calculate stand mean (.tif)"),
                                                            optional=True))
        # Coniferous raster to calculate stand mean
        self.addParameter(QgsProcessingParameterRasterLayer(self.CONIFEROUS_RASTER_FOR_CLASSIFICATION,
                                                            self.tr(
                                                                "Coniferous raster to be used during stand delineation (.tif)"
                                                                "\nA simplified binarized raster may achieve better results (optional)"),
                                                            optional=True))
        # Perimeter shapefile to clip final result                                 
        self.addParameter(
            QgsProcessingParameterFeatureSource(self.PERIMETER, self.tr("Perimeter shapefile to clip final result"),
                                                [QgsProcessing.TypeVectorPolygon]))

        # Folder for algorithm output
        self.addParameter(QgsProcessingParameterFolderDestination(self.OUTPUT_ROOT, self.tr('Output folder'
                                                                                            '\n(a subfolder with timestamp will be created within)')))

        # --- Advanced Parameters
        parameter = QgsProcessingParameterBoolean(self.USE_CONFEROUS_FOR_CLASSIFICATION,
                                                  self.tr("Consider coniferous raster for classification"),
                                                  defaultValue=True)
        self.addAdvancedParameter(parameter)

        # Zone raster is currently hidden,
        parameter = QgsProcessingParameterRasterLayer(self.ZONE_RASTER_FILE, self.tr("Zone raster (.tif)"),
                                                      optional=True)
        self.addHiddenParameter(parameter)

        parameter = QgsProcessingParameterString(self.LOGFILE_NAME, self.tr("Log File Name (.log)"),
                                                 defaultValue="tbk_processing.log")
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterString(self.DESCRIPTION, self.tr("Short description"),
                                                 defaultValue="TBk dataset")
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.MIN_TOL, self.tr("Relative min tolerance"),
                                                 type=QgsProcessingParameterNumber.Double, defaultValue=0.1)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.MAX_TOL, self.tr("Relative max tolerance"),
                                                 type=QgsProcessingParameterNumber.Double, defaultValue=0.1)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.MIN_CORR, self.tr("Extension of the range down [m]"),
                                                 type=QgsProcessingParameterNumber.Double, defaultValue=4)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.MAX_CORR, self.tr("Extension of the range up [m]"),
                                                 type=QgsProcessingParameterNumber.Double, defaultValue=4)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.MIN_VALID_CELLS,
                                                 self.tr("Minimum relative amount of valid cells"),
                                                 type=QgsProcessingParameterNumber.Double, defaultValue=0.5)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.MIN_CELLS_PER_STAND, self.tr("Minimum cells per stand"),
                                                 type=QgsProcessingParameterNumber.Integer, defaultValue=10)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.MIN_CELLS_PER_PURE_STAND,
                                                 self.tr("Minimum cells for pure mixture stands"),
                                                 type=QgsProcessingParameterNumber.Integer, defaultValue=30)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.VHM_MIN_HEIGHT, self.tr("VHM minimum height"),
                                                 type=QgsProcessingParameterNumber.Double, defaultValue=0)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.VHM_MAX_HEIGHT, self.tr("VHM maximum height"),
                                                 type=QgsProcessingParameterNumber.Double, defaultValue=60)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.SIMPLIFICATION_TOLERANCE, self.tr("Simplification tolerance [m]"),
                                                 type=QgsProcessingParameterNumber.Double, defaultValue=8)
        self.addAdvancedParameter(parameter)

        #    # Additional parameters
        parameter = QgsProcessingParameterNumber(self.MIN_AREA_M2, self.tr("Min. area to eliminate small stands"),
                                                 type=QgsProcessingParameterNumber.Integer, defaultValue=1000)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.SIMILAR_NEIGHBOURS_MIN_AREA_M2,
                                                 self.tr("Min. area to merge similar stands"),
                                                 type=QgsProcessingParameterNumber.Integer, defaultValue=2000)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterNumber(self.SIMILAR_NEIGHBOURS_HDOM_DIFF_REL,
                                                 self.tr("hdom relative diff to merge similar stands"),
                                                 type=QgsProcessingParameterNumber.Double, defaultValue=0.15)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterBoolean(self.CALC_MIXTURE_FOR_MAIN_LAYER,
                                                  self.tr("Also calc coniferous prop. for main layer"),
                                                  defaultValue=True)
        self.addAdvancedParameter(parameter)

        parameter = QgsProcessingParameterBoolean(self.DEL_TMP, self.tr("Delete temporary files and fields"),
                                                  defaultValue=True)
        self.addAdvancedParameter(parameter)

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # ------- INIT Algorithm -------#

        # settings_path = QgsApplication.qgisSettingsDirPath()
        # tbk_tool_path = os.path.join(settings_path,"python/plugins/tbk_qgis")
        tbk_tool_path = os.path.dirname(__file__)  # needed for calling create project script

        # --- get and check input parameters

        # get and check general input parameters
        output_root = self.parameterAsString(parameters, self.OUTPUT_ROOT, context)
        # get and check logfile
        logfile_name = str(self.parameterAsString(parameters, self.LOGFILE_NAME, context))
        if (not logfile_name) or logfile_name == "":
            raise QgsProcessingException("no logfile name specified")

        # get and check paths to VHMs
        vhm_10m = str(self.parameterAsRasterLayer(parameters, self.VHM_10M, context).source())
        if not os.path.splitext(vhm_10m)[1].lower() in (".tif", ".tiff"):
            raise QgsProcessingException("vhm_10m must be a TIFF file")
        vhm_150cm = str(self.parameterAsRasterLayer(parameters, self.VHM_150CM, context).source())
        if not os.path.splitext(vhm_150cm)[1].lower() in (".tif", ".tiff"):
            raise QgsProcessingException("vhm_150cm must be a TIFF file")

        # get and check coniferous Raster / settings
        useConiferousRaster = self.parameterAsBool(parameters, self.USE_CONFEROUS_FOR_CLASSIFICATION, context)
        coniferous_raster_layer = self.parameterAsRasterLayer(parameters, self.CONIFEROUS_RASTER, context)
        coniferous_raster = None
        if coniferous_raster_layer:
            coniferous_raster = str(coniferous_raster_layer.source())
        if coniferous_raster and (not os.path.splitext(coniferous_raster)[1].lower() in (".tif", ".tiff")):
            raise QgsProcessingException("coniferous_raster must be a TIFF file")

        # init coniferous_raster_for_classification and read from parameters if provided
        coniferous_raster_for_classification = None
        coniferous_raster_for_classification_layer = self.parameterAsRasterLayer(parameters,
                                                                                 self.CONIFEROUS_RASTER_FOR_CLASSIFICATION,
                                                                                 context)
        if coniferous_raster_for_classification_layer:
            coniferous_raster_for_classification = str(coniferous_raster_for_classification_layer.source())
        if coniferous_raster_for_classification and (
                not os.path.splitext(coniferous_raster_for_classification)[1].lower() in (".tif", ".tiff")):
            raise QgsProcessingException("coniferous_raster_for_classification must be a TIFF file")

        # if no explicit coniferous_raster_for_classification is provided, try using coniferous_raster, else complain
        if useConiferousRaster and (coniferous_raster_for_classification is None):
            if coniferous_raster is None:
                coniferous_raster_for_classification = coniferous_raster
                print("Using coniferous raster for classification.")
                # feedback.pushInfo("Using coniferous raster for classification.")
            else:
                raise QgsProcessingException("coniferous_raster is not not specified")
        else:
            print("Using coniferous raster for classification.")
            # feedback.pushInfo("Using coniferous raster for classification.")

        calc_mixture_for_main_layer = self.parameterAsBool(parameters, self.CALC_MIXTURE_FOR_MAIN_LAYER, context)
        if calc_mixture_for_main_layer and coniferous_raster == None:
            raise QgsProcessingException("No coniferous_raster specified")

        # get and check perimeter file
        perimeter = str(self.parameterAsVectorLayer(parameters, self.PERIMETER, context).source())
        # TODO maybe check geometry?

        # get and check zone raster file
        zoneRasterFile_layer = self.parameterAsRasterLayer(parameters, self.ZONE_RASTER_FILE, context)
        zoneRasterFile = None
        if zoneRasterFile_layer:
            zoneRasterFile = str(zoneRasterFile_layer.source())
        if zoneRasterFile and (not os.path.splitext(zoneRasterFile)[1].lower() in (".tif", ".tiff")):
            raise QgsProcessingException("zoneRasterFile must be a TIFF file")
        if (not zoneRasterFile) or (zoneRasterFile == "") or zoneRasterFile is None:
            zoneRasterFile = "null"

        # get and check description
        description = str(self.parameterAsString(parameters, self.DESCRIPTION, context))
        if (not description) or description == "":
            description = "TBk dataset"
        # TODO use description for naming the output/project file

        # get and check algorithm parameters
        min_tol = self.parameterAsDouble(parameters, self.MIN_TOL, context)
        max_tol = self.parameterAsDouble(parameters, self.MAX_TOL, context)
        min_corr = self.parameterAsDouble(parameters, self.MIN_CORR, context)
        max_corr = self.parameterAsDouble(parameters, self.MAX_CORR, context)
        min_valid_cells = self.parameterAsDouble(parameters, self.MIN_VALID_CELLS, context)
        min_cells_per_stand = self.parameterAsInt(parameters, self.MIN_CELLS_PER_STAND, context)
        min_cells_per_pure_stand = self.parameterAsInt(parameters, self.MIN_CELLS_PER_PURE_STAND, context)
        vhm_min_height = self.parameterAsDouble(parameters, self.VHM_MIN_HEIGHT, context)
        vhm_max_height = self.parameterAsDouble(parameters, self.VHM_MAX_HEIGHT, context)

        simplification_tolerance = self.parameterAsDouble(parameters, self.SIMPLIFICATION_TOLERANCE, context)

        min_area_m2 = self.parameterAsInt(parameters, self.MIN_AREA_M2, context)
        similar_neighbours_min_area = self.parameterAsInt(parameters, self.SIMILAR_NEIGHBOURS_MIN_AREA_M2, context)
        similar_neighbours_hdom_diff_rel = self.parameterAsDouble(parameters, self.SIMILAR_NEIGHBOURS_HDOM_DIFF_REL,
                                                                  context)

        # get and check miscellaneous parameters
        del_tmp = self.parameterAsBool(parameters, self.DEL_TMP, context)

        # get configuration file path
        config_path = self.parameterAsString(parameters, self.CONFIG_FILE, context)

        # --- Set input parameters from config file

        input_parameters = read_dict_from_json_file(config_path)

        calc_mixture_for_main_layer = bool(input_parameters["calc_mixture_for_main_layer"])
        #coniferous_raster = input_parameters["coniferous_raster"]
        #coniferous_raster_for_classification = input_parameters["coniferous_raster_for_classification"]
        del_tmp = bool(input_parameters["del_tmp"])
        description = input_parameters["description"]
        logfile_name = input_parameters["logfile_name"]
        max_corr = int(input_parameters["max_corr"])
        max_tol = int(input_parameters["max_tol"])
        min_valid_cells = int(input_parameters["min_valid_cells"])
        output_root = input_parameters["output_root"]
        perimeter = input_parameters["perimeter"]
        similar_neighbours_hdom_diff_rel = int(input_parameters["similar_neighbours_hdom_diff_rel"])
        similar_neighbours_min_area = int(input_parameters["similar_neighbours_min_area"])
        simplification_tolerance = int(input_parameters["simplification_tolerance"])
        useConiferousRaster = bool(input_parameters["useConiferousRasterForClassification"])
        vhm_10m = input_parameters["vhm_10m"]
        vhm_150cm = input_parameters["vhm_150cm"]
        vhm_max_height = int(input_parameters["vhm_max_height"])
        vhm_min_height = int(input_parameters["vhm_min_height"])


        # --- init directory
        ensure_dir(output_root)

        # Set up directory with timestamp in working_root
        output_root = os.path.join(output_root, '')  # Add the trailing slash if it's not already there.
        currentDatetime = datetime.now().strftime("%Y%m%d-%H%M")
        outputDirectory = currentDatetime
        tbk_result_dir = os.path.join(output_root, outputDirectory)
        tbk_result_dir = os.path.join(tbk_result_dir, '')  # Add the trailing slash if it's not already there.

        working_root = os.path.join(tbk_result_dir, 'bk_process', '')  # create subfolder (and add trailing slash)
        # create working root and all intermediate folders
        ensure_dir(working_root)
        tmp_output_folder = os.path.join(working_root, "tmp")
        # create tmp folder and all intermediate folders
        ensure_dir(tmp_output_folder)

        # --- configure logging
        logfile_tmp_path = os.path.join(working_root, logfile_name)

        # set up logging to file
        logging.basicConfig(
            filename=logfile_tmp_path,
            level=logging.DEBUG,
            format='[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',
            # format="%(asctime)s; %(processName)s; %(levelname)s; %(name)s; %(message)s",
            datefmt='%H:%M:%S'
        )

        # set up logging to console
        console = logging.StreamHandler()
        console.setLevel(logging.DEBUG)
        # set a format which is simpler for console use
        formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
        console.setFormatter(formatter)
        # add the handler to the root logger
        logging.getLogger('').addHandler(console)

        # set up logging to QGIS feedback
        qgis_console = QgisHandler(feedback)
        qgis_console.setLevel(logging.DEBUG)
        # add the handler to the root logger
        logging.getLogger('').addHandler(console)

        # logger = logging.getLogger(__name__)
        # logging.basicConfig(
        #     level=logging.INFO,
        #     format="%(asctime)s; %(processName)s; %(levelname)s; %(name)s; %(message)s",
        #     handlers=[
        #         logging.FileHandler(logfile_tmp_path, mode='w'),
        #         QgisHandler(feedback),
        #         logging.StreamHandler()
        #     ])

        log = logging.getLogger('')

        log.info('Run TBk')

        # ------- TBk MAIN Processing --------#

        # store the input parameters in a file
        write_dict_to_json_file(tbk_result_dir, parameters)

        # Run TBk
        start_time = time.time()

        # --- Stand delineation (Main)
        log.info('Stand delineation')
        run_stand_classification(working_root, tmp_output_folder,
                                 vhm_10m, coniferous_raster_for_classification,
                                 zoneRasterFile, description,
                                 min_tol, max_tol,
                                 min_corr, max_corr,
                                 min_valid_cells, min_cells_per_stand, min_cells_per_pure_stand,
                                 vhm_min_height, vhm_max_height)

        # --- Simplify & Eliminate
        log.info('Simplify & Eliminate')
        post_process(working_root, tmp_output_folder, min_area_m2, simplification_tolerance=simplification_tolerance,
                     del_tmp=del_tmp)

        # --- Merge similar neighbours
        log.info('Merge similar neighbours')
        merge_similar_neighbours(working_root, tmp_output_folder, similar_neighbours_min_area,
                                 similar_neighbours_hdom_diff_rel,
                                 del_tmp=del_tmp)

        # --- Clip to perimeter and eliminate gaps
        log.info('Clip to perimeter and eliminate gaps')
        # run clip function
        clip_to_perimeter(working_root, tmp_output_folder, perimeter, del_tmp=del_tmp)
        # run gaps function
        eliminate_gaps(working_root, tmp_output_folder, perimeter, del_tmp=del_tmp)

        # --- Calculate DG
        log.info('Calculate DG')
        calculate_dg(working_root, tmp_output_folder, tbk_result_dir, vhm_150cm, del_tmp=del_tmp)

        # --- Add coniferous proportion
        if calc_mixture_for_main_layer:
            log.info('Add coniferous proportion')
            add_coniferous_proportion(working_root, tmp_output_folder, tbk_result_dir, coniferous_raster,
                                      calc_mixture_for_main_layer, del_tmp=del_tmp)

        # --- Calc specific attributes
        log.info('Calc specific attributes')
        stands_file_attributed = calc_attributes(working_root, tmp_output_folder, tbk_result_dir, del_tmp=del_tmp)

        # --- run cleanup and write final stand file
        log.info('Run clean up')
        stands_file_cleaned = os.path.join(tmp_output_folder, "TBk_Bestandeskarte_clean.gpkg")
        processing.run("TBk:TBk postprocess Cleanup", {
            'tbk_bestandeskarte': stands_file_attributed,
            'Tbk_bestandeskarte_clean': stands_file_cleaned})

        # --- Clean up unneeded fields

        # if del_tmp:
        #     log.info('Remove obsolete fields in TBk_Bestandeskarte')
        #     del_fields = ["FID_orig", "OBJECTID", "fid", "fid_1", "NH_CLASS"]
        #     delete_fields(QgsVectorLayer(result_stand_path, "layer", "ogr"), del_fields)

        # remove fid with processing tool, as deleting doesn't seem to work
        # stands_file_fid_del = os.path.join(tmp_output_folder, "TBk_Bestandeskarte_fiddel.gpkg")
        stands_file_final = os.path.join(tbk_result_dir, "TBk_Bestandeskarte.gpkg")

        processing.run("native:deletecolumn", {
            'INPUT': stands_file_cleaned,
            'COLUMN': ['fid', 'FID_orig', 'OBJECTID', 'NH_CLASS'],
            'OUTPUT': stands_file_final})

        # --- Delete tmp directory
        if del_tmp:
            log.info(f'Delete temporary files: {tmp_output_folder}')
            # TODO: this usually fails with a Permission Error, since QGIS doesn't seem to close the file handles
            # PermissionError: [WinError 32] The process cannot access the file because it is being used by another process:
            # 'C:\\Users\\hbh1\\Projects\\H07_TBk\\Dev\\TBk_QGIS_Plugin\\data\\tbk_hafl\\tbk2012_v02\\20240414-2304\\bk_process\\tmp\\gaps_single_tmp.gpkg'
            # shutil.rmtree(tmp_output_folder, ignore_errors=True)

        # TODO:
        # Delete stands < 100 m2
        # Delete stands without geometry
        # Repair geometry
        # Add incremental field (sort based on ID)

        # --- Create default Project
        log.info('Create default Project')
        # os.system("\"" + arcgis_python + "\" " + tbk_tool_path + "\\post_processing_arcpy\\create_mxd.py" +
        #           " " + working_root + " " + tbk_tool_path + " " + working_root + " " + vhm_10m + " " + vhm_150cm)

        # Run Script in separate process, since otherwise the current project would be unloaded
        # make sure the called python environment has all necessary modules on PYTHONPATH
        qgisPath = QgsApplication.prefixPath()
        qgisPythonPath = os.path.join(qgisPath, "python")
        if "PYTHONPATH" in os.environ:
            # append to PYTHONPATH
            os.environ["PYTHONPATH"] = qgisPythonPath + os.pathsep + os.environ["PYTHONPATH"]
        else:
            # create PYTHONPATH
            os.environ["PYTHONPATH"] = qgisPythonPath

        # construct a python call command with all necessary paramters and call
        script_path = os.path.join(tbk_tool_path, "create_project.py")
        command = "python3.exe \"" + script_path.replace("\\", "/") + "\" \"" \
                  + working_root.replace("\\", "/") + "\" \"" \
                  + tmp_output_folder.replace("\\", "/") + "\" \"" \
                  + tbk_result_dir.replace("\\", "/") + "\" \"" \
                  + tbk_tool_path.replace("\\", "/") + "\" \"" \
                  + vhm_10m + "\" \"" \
                  + vhm_150cm + "\" \"" \
                  + coniferous_raster + "\" \"" \
                  + str(del_tmp) + "\""

        log.info(command)
        os.system(command)

        # if del_tmp:
        #     output_tmp_folder = os.path.join(working_root,"tmp")
        #     if os.path.isdir(output_tmp_folder):
        #         shutil.rmtree(output_tmp_folder)

        # --- Copy temporary logfile to result directory
        # log.info("Copy logfile from: " + logfile_tmp_path)
        # logfile = os.path.join(working_root, logfile_name)
        # log.info("Copy logfile to: " + logfile)
        # copyfile(logfile_tmp_path, logfile)

        # finished
        feedback.pushInfo("====================================================================")
        feedback.pushInfo("FINISHED")
        feedback.pushInfo("TOTAL PROCESSING TIME: %s (h:min:sec)" % str(timedelta(seconds=(time.time() - start_time))))
        feedback.pushInfo("====================================================================")
        log.info('FINISHED')

        #        # Compute the number of steps to display within the progress bar and
        #        # get features from source
        #        total = 100.0 / source.featureCount() if source.featureCount() else 0
        #        features = source.getFeatures()
        #
        #        for current, feature in enumerate(features):
        #            # Stop the algorithm if cancel button has been clicked
        #            if feedback.isCanceled():
        #                break
        #
        #            # Add a feature in the sink
        #            #sink.addFeature(feature, QgsFeatureSink.FastInsert)
        #
        #            # Update the progress bar
        #            feedback.setProgress(int(current * total))

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT: working_root}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Generate BK'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        # return self.tr(self.groupId())
        return '1 Bk generation (core)'

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'tbkcore'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return TBkAlgorithm()
